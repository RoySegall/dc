<?php
/**
 * @file
 * Main file of the module Drupal publisher publisher.
 */

/**
 * Implements hook_menu().
 */
function dc_publisher_menu() {
  $items = array();

  $items['admin/apps/%dc_apps/documentation'] = array(
    'title' => 'Documentation',
    'description' => 'View documentation of an app',
    'access arguments' => array('view documentation'),
    'page callback' => 'dc_publisher_documentation',
    'page arguments' => array(2),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/apps/%dc_apps/documentation/%'] = array(
    'title callback' => 'dc_publisher_documentation_specific_title',
    'title arguments' => array(2, 4),
    'access callback' => 'dc_publisher_documentation_specific_access',
    'access arguments' => array(2, 4),
    'page callback' => 'dc_publisher_documentation_specific',
    'page arguments' => array(2, 4),
  );

  $items['publisher'] = array(
    'title' => 'Publisher',
    'description' => 'Supplying JSON information for an app',
    'access callback' => 'dc_publisher_oatuh_allowed',
    'page callback' => 'dc_publisher_supply_information',
  );

  $items['dc-connect'] = array(
    'title' => 'Connect',
    'description' => 'Allow to pull information from user',
    'access callback' => 'dc_publisher_oatuh_allowed',
    'page callback' => 'dc_publisher_connect_with',
  );

  $items['apps/%dc_apps/user_approve_app'] = array(
    'title' => 'Approve app',
    'description' => 'Allow to user approve app',
    'access callback' => 'dc_publisher_user_approve_app_access',
    'access arguments' => array(1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dc_publisher_user_approve_app', 1),
  );

  $items['user/%user/apps'] = array(
    'title' => 'Apps',
    'description' => 'Manage your approved apps',
    'access callback' => 'dc_publisher_manage_apps_access',
    'access arguments' => array(1),
    'page callback' => 'dc_publisher_manage_apps',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  $items['user/%user/apps/%/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit an approval of an apps',
    'access arguments' => array('manage approved apps'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dc_publisher_edit_approve', 1, 3),
  );

  $items['user/%user/apps/%/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete an approval of an apps',
    'access arguments' => array('manage approved apps'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dc_publisher_delete_approve', 1, 3),
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function dc_publisher_admin_paths() {
  return array(
    'user/*/apps/*/edit' => FALSE,
  );
}

/**
 * Implements hook_entity_info().
 */
function dc_publisher_entity_info() {
  return array(
    'approved_apps' => array(
      'label' => t('Approved app'),
      'entity class' => 'DrupalPublisherApprovedApp',
      'controller class' => 'EntityAPIController',
      'base table' => 'approved_apps',
      'entity keys' => array(
        'id' => 'id',
      ),
      'load hook' => '',
    ),
  );
}

/**
 * Create Drupal publisher approved app entity.
 *
 * @param $data
 *  Initialize data of the Drupal publisher app.
 *
 * @return DrupalPublisherApprovedApp
 *  Initialized object a Drupal publisher approved app.
 */
function dc_publisher_approved_apps_create($data = array()) {
  global $user;

  $data += array(
    'uid' => $user->uid,
    'timestamp' => REQUEST_TIME,
  );

  return entity_create('approved_apps', $data);
}

/**
 * Load multiple Drupal publisher approved app entity.
 *
 * @param $ids
 *  Array of Drupal publisher apps IDs.
 *
 * @return DrupalPublisherApprovedApp[]
 *  Array of Drupal publisher approved apps objects.
 */
function dc_publisher_approved_apps_load_multiple($ids) {
  return entity_load('approved_apps', $ids);
}

/**
 * Load a single Drupal publisher approved app entity.
 *
 * @param $id
 *  Id a Drupal publisher app entity.
 *
 * @return DrupalPublisherApprovedApp
 *  Drupal publisher approved apps object.
 */
function dc_publisher_approved_apps_load($id) {
  $entity = entity_load('approved_apps', array($id));
  return reset($entity);
}

/**
 * Delete multiple Drupal publisher approved app entities.
 *
 * @param $ids
 *  List of Drupal publisher app IDs to delete.
 */
function dc_publisher_approved_apps_delete_multiple($ids) {
  entity_delete_multiple('approved_apps', $ids);
}

/**
 * Implements hook_entity_delete().
 *
 * After deleting an app we don't need any more the approval of users for that
 * app. We need to delete in batch 250 approval at a time.
 * This will be done via a queue worker.
 */
function dc_publisher_entity_delete($entity, $type) {
  if ($type != 'dc_app') {
    return;
  }

  // TODO: Do. http://www.youtube.com/watch?v=Ra70O9nps6E
}

/**
 * Implements hook_theme().
 */
function dc_publisher_theme() {
  return array(
    'admin_app_documentation' => array(
      'variables' => array(
        'title' => NULL,
        'description' => NULL,
        'url' => NULL,
      ),
      'template' => 'admin-app-documentation',
      'path' => drupal_get_path('module', 'dc_publisher') . '/templates'
    ),
  );
}

/**
 * Return the basic address of the the site oauth publisher page.
 */
function dc_publisher_base_url($q = 'publisher') {
  global $base_url;

  return $base_url . '?q=' . $q;
}

/**
 * When oatuh want to pull data he need to pass the oauth signature test.
 */
function dc_publisher_oatuh_allowed() {
  if (!isset($_GET['key']) || !isset($_GET['secret'])) {
    return;
  }

  $reader = new DrupalConnect($_GET['key'], $_GET['secret']);
  $reader
    ->SetUrl(dc_publisher_base_url($_GET['q']))
    ->SetOauthRequest();

  return $reader->VerifySignature($_GET['signature']);
}

/**
 * Page callback - supply the information the oauth service selected.
 */
function dc_publisher_supply_information() {
  $app = dc_apps_load_by_keys($_GET['key'], $_GET['secret']);

  if (!$app) {
    // No app found - return nothing.
    drupal_json_output(t("App with the key and secret wasn't found"));
  }

  if (!in_array($_GET['data'], array_keys($app->need))) {
    drupal_json_output(t("The @data information you selected cannot be supplied due to app settings.", array('@data' => $_GET['data'])));
  }

  // Start the query.
  $query = new entityFieldQuery();
  $query->entityCondition('entity_type', $_GET['data']);

  // When searching for users and the checkbox was checked only users which
  // approve the app will be display in the search results.
  if (variable_get('apps_search_for_users_limit', FALSE) && $_GET['data'] == 'user') {
    // Adding tag for altering query later on.
    $query->addTag('dc_publisher_approved_apps');

    // Adding the app id for the join.
    $query->addMetaData('app_id', $app->id);
  }

  // Find the field to work upon and the operator to apply.
  if (isset($_GET['search'])) {
    $info = $app->need[$_GET['data']];
    $entity_info = entity_get_info($_GET['data']);

    // Check if the we looking for data in a field or in a property.
    if (in_array($info['search'], $entity_info['schema_fields_sql']['base table'])) {
      // Adding the property to the query.
      $query->propertyCondition($info['search'], $_GET['search'], $info['operator']);
    }
    else {
      // Loading the field info for knowing the storage fields so we could know
      // on which column the search will be applied.
      $field_info = field_info_field($info['search']);
      $storage_information = array_keys($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']['field_data_body']);

      // Usually, the first column in the storage information holds the value of
      // the field. We can count on that.
      $search_column = reset($storage_information);

      // Let other modules with special fields to alter the search column.
      drupal_alter('dc_publisher_field_search_column_alter', $search_column, $field_info);

      // Add the field to the query.
      $query->fieldCondition($info['search'], $search_column, $_GET['search'], $info['operator']);
    }
  }

  // Display in batches.
  $result_number = variable_get('apps_data_number', 25);
  $page = !empty($_GET['page']) ? $_GET['page'] * $result_number : 0;
  $query->range($page, $result_number);

  // Execute.
  $result = $query->execute();

  if (empty($result[$_GET['data']])) {
    drupal_json_output(t('No data were found according to you search curatorial.'));
  }

  $content = '';
  $resource = restws_resource_controller($_GET['data']);
  $format = restws_format('json');

  // Supply the information.
  // TODO: Add how much results were found. This will be used when people pull
  // information in batches.
  foreach (array_keys($result[$_GET['data']]) as $id) {
    // Un-serialized the data for building an array of results.
    $content[] = drupal_json_decode($format->viewResource($resource, $id, TRUE));
  }

  // Print the serialized information.
  print $format->serialize($content);
  drupal_add_http_header('Content-Type', $format->mimeType());
}

/**
 * Implements hook_query_QUERY_TAG_alter().
 *
 * The administrator define that apps searching for users can get the users
 * which approved the app.
 */
function dc_publisher_query_dc_publisher_approved_apps_alter(QueryAlterableInterface $query) {
  $app_id = $query->getMetaData('app_id');

  $query->join('approved_apps', 'approve', "approve.uid = users.uid");
  $query->condition('approve.app_id', $app_id);
  $query->condition('approve.status', 1);
}

/**
 * A client asked to connect with a user - supply the information about the
 * user.
 */
function dc_publisher_connect_with() {
  global $user;

  $app = dc_apps_load_by_keys($_GET['key'], $_GET['secret']);


  $_SESSION['dc_publisher'] = array(
    'key' => $_GET['key'],
    'secret' => $_GET['secret'],
    'signature' => $_GET['signature'],
  );

  // Check that user is logged in.
  if (!user_is_logged_in()) {
    // Redirect the user for logging in.
    drupal_goto('user/login');
    return;
  }

  if (!dc_apps_user_approved_apps($app)) {
    // Redirect the user to approve the app.
  }

  drupal_json_output($user);
}

/**
 * Implements hook_permission().
 */
function dc_publisher_permission() {
  return array(
    'view documentation' => array(
      'title' => t('View documentation'),
      'description' => t('Allow to the user watch the documentation of an app.'),
    ),
    'manage approved apps' => array(
      'title' => t('Manage user own apps'),
      'description' => t('Allow to user manage his approved apps.'),
    ),
    'manage other approved apps' => array(
      'title' => t('Manage user own apps'),
      'description' => t('Allow to user manage his approved apps.'),
    ),
  );
}

/**
 * Implements hook_dc_apps_generate_links_action_alter().
 */
function dc_publisher_dc_apps_generate_links_action_alter(&$actions, DrupalConnectApps $app) {
  $actions['documentation'] = array(
    'title' => t('Documentation'),
    'href' => 'admin/apps/' . $app->id . '/documentation',
  );
}

/**
 * Implements hook_dc_apps_app_options_alter().
 */
function dc_publisher_dc_apps_app_options_alter(&$items, DrupalConnectApps $app) {
  $items[] = $app->generateLink('documentation');
}

/**
 * Display documentation for an app.
 */
function dc_publisher_documentation(DrupalConnectapps $app) {
  $reader = new DrupalConnect($app->app_key, $app->app_secret);
  $reader
    ->SetUrl(dc_publisher_base_url())
    ->SetOauthRequest()
    ->SetSignatureParameter();

  $urls = array();

  foreach (array_keys($app->need) as $entity) {
    $urls[] = l($entity, 'admin/apps/' . $app->id . '/documentation/' . $entity);
  }

  return theme('item_list', array('items' => $urls));
}

/**
 * Access callback for determine if the user can approve the app.
 */
function dc_publisher_user_approve_app_access(DrupalConnectApps $app, $account = NULL) {

  // Anonymous users are not allowed to approve any app.
  if (!user_is_logged_in()) {
    return FALSE;
  }

  // Load the current user.
  if (!$account) {
    global $user;
    $account = user_load($user->uid);
  }

  // See if the user approved this app before.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'approved_apps')
    ->propertyCondition('app_id', $app->id)
    ->propertyCondition('uid', $account->uid)
    ->execute();

  return empty($result['approved_apps']);
}

/**
 * Displaying the form for approving apps.
 */
function dc_publisher_user_approve_app($form, &$form_state, DrupalConnectApps $app) {
  $form_state['#entity'] = $app;

  return confirm_form($form,
    t('Are you approving @title?', array('@title' => $app->title)),
    'admin/apps',
    t('This app need your approve for accessing your information. Are you approve this operation?'),
    t('Approve'),
    t('Cancel')
  );
}

/**
 * Submit handler - user approved the app. Save it and redirect the to where
 * he came from.
 */
function dc_publisher_user_approve_app_submit($form, &$form_state) {
  global $base_url, $user;
  $form_state['redirect'] = $base_url;
  $app = $form_state['#entity'];

  $approve = dc_publisher_approved_apps_create();
  $approve->uid = $user->uid;
  $approve->app_id = $app->id;
  $approve->save();

  drupal_set_message(t('The app @name has been approved. Thank you.', array('@name' => $app->title)));
}

/**
 * Access callback for determine if the user can manage the apps of a user.
 *
 * @param $account
 *  The user account.
 *
 * @return bool
 *  True or false if the user can do the action.
 */
function dc_publisher_manage_apps_access($account) {
  global $user;

  $string = $account->uid == $user->uid ? 'manage approved apps' : 'manage other approved apps';

  return user_access($string);
}

/**
 * Allow to user manage his apps.
 */
function dc_publisher_manage_apps($account) {
  // TODO: Cache.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'approved_apps')
    ->propertyCondition('uid', $account->uid)
    ->execute();

  $header = array(
    t('Application name'),
    array('data' => t('Options'), 'colspan' => 2),
  );

  $rows = array();
  if (empty($result['approved_apps'])) {
    $rows[] = array(array('data' => t('None approved apps were found'), 'colspan' => 3));
  }
  else {
    // Get the approved apps ID.
    $apps_id = array();
    $approved_apps = dc_publisher_approved_apps_load_multiple(array_keys($result['approved_apps']));
    foreach ($approved_apps as $approve) {
      $apps_id[$approve->app_id] = $approve;
    }

    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'dc_app')
      ->propertyCondition('id', array_keys($apps_id))
      ->execute();

    $apps = dc_apps_load_multiple(array_keys($result['dc_app']));

    foreach ($apps as $app) {
      $rows[] = array(
        $app->title,
        l(t('Edit'), 'user/' . $account->uid . '/apps/' . $apps_id[$app->id]->id . '/edit'),
        l(t('Delete'), 'user/' . $account->uid . '/apps/' . $apps_id[$app->id]->id . '/delete'),
      );
    }
  }

  $content = theme('table', array('header' => $header, 'rows' => $rows));

  return $content;
}

/**
 * Edit application approve status.
 */
function dc_publisher_edit_approve($form, &$form_state, $user, $approve_id) {
  $approve = dc_publisher_approved_apps_load($approve_id);
  $form_state['#entity'] = $approve;
  $form_state['#user'] = $user;

  $form['status'] = array(
    '#type' => 'select',
    '#title' => t('Status'),
    '#options' => array(
      0 => t('Disabled'),
      1 => t('Enabled'),
    ),
    '#default_value' => $approve->status,
  );

  $form['actions'] = array(
    '#type' => 'actions',
    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Submit'),
    ),
    'cancel' => array(
      '#type' => 'markup',
      '#markup' => l(t('Delete'), 'user/' . $user->uid . '/apps/' . $approve_id . '/delete'),
      '#suffix' => ' ',
    ),
    'delete' => array(
      '#type' => 'markup',
      '#markup' => l(t('Cancel'), 'user/' . $user->uid . '/apps'),
    ),
  );

  return $form;
}

/**
 * Submit handler for edit application approve status.
 */
function dc_publisher_edit_approve_submit($form, &$form_state) {
  $approve = $form_state['#entity'];
  $user = $form_state['#user'];

  $form_state['redirect'] = 'user/' . $user->uid . '/apps';

  $approve->status = $form_state['values']['status'];
  $approve->save();
}

/**
 * Delete approve of an application.
 */
function dc_publisher_delete_approve($form, &$form_state, $user, $approve_id) {
  $approve = dc_publisher_approved_apps_load($approve_id);
  $form_state['#entity'] = $approve;
  $form_state['#user'] = $user;

  return confirm_form($form,
    t('Are you sure you want to remove the approve for the app @title?', array('@title' => $approve->app()->title)),
    'user/' . $user->uid . '/apps',
    t('This action cannot be reversed.'),
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Submit handler for delete approve of an application.
 */
function dc_publisher_delete_approve_submit($form, &$form_state) {
  $approve = $form_state['#entity'];
  $user = $form_state['#user'];

  $form_state['redirect'] = 'user/' . $user->uid . '/apps';

  $approve->delete();
}

/**
 * Access callback for the title of the specific documentation.
 */
function dc_publisher_documentation_specific_title(DrupalConnectApps $app, $type) {
  $entity = entity_get_info($type);
  return t('@type documentation for @app', array('@type' => $entity['label'], '@app' => $app->title));
}

/**
 * Access callback for specific entity documentation.
 */
function dc_publisher_documentation_specific_access(DrupalConnectApps $app, $type) {
  if (!in_array($type, array_keys($app->need))) {
    $params = array(
      '@type' => $type,
    );
    drupal_set_message(t('The app @type is not listed in of the need entities.', $params), 'warning');
    return FALSE;
  }

  return user_access('view documentation');
}

/**
 * Display specific app documentation.
 */
function dc_publisher_documentation_specific(DrupalConnectApps $app, $type) {
  $reader = new DrupalConnect($app->app_key, $app->app_secret);

  $reader
    ->SetUrl(dc_publisher_base_url())
    ->SetOauthRequest()
    ->SetSignatureParameter();

  $reader->request->set_parameter('data', $type);

  $information = array(
    array(
      'title' => t('General'),
      'description' => t('Displaying all the results for this entity.'),
      'link_parameters' => array(
      ),
    ),
    array(
      'title' => t('Search'),
      'description' => t('When creating an app you select a field and operator. Using the search variable you can reduce results.'),
      'link_parameters' => array(
        'search' => 'foo',
      ),
    ),
    array(
      'title' => t('Pager'),
      'description' => t('Each call return 25 results. When you have more then 25 results you can use the pager value. <i>Notice: The first start from 0, the second is 1</i>'),
      'link_parameters' => array(
        'page' => '1',
      ),
    ),
  );

  $content = '';
  foreach ($information as $info) {

    foreach ($info['link_parameters'] as $key => $value) {
      $reader->request->set_parameter($key, $value);
    }

    $url = l(t('Watch results'), $reader->getUrl());

    // TODO: Add option to see raw URL or how to use the DrupalConnect class.
    $content .= theme('admin_app_documentation', array(
      'title' => $info['title'],
      'description' => $info['description'],
      'url' => $url,
    ));

    foreach (array_keys($info['link_parameters']) as $key) {
      $reader->request->unset_parameter($key);
    }
  }

  return $content;
}

/**
 * Implements hook_user_login().
 *
 * If the user has a dc_publisher information in the session then we need to
 * redirect the user to approve the app.
 * Submit handler - redirect the user to the Login with page.
 */
function dc_publisher_user_login(&$form, &$form_state) {
  if (empty($_SESSION['dc_publisher'])) {
    return;
  }

  $query = array(
    'key' => $_SESSION['dc_publisher']['key'],
    'secret' => $_SESSION['dc_publisher']['secret'],
    'signature' => $_SESSION['dc_publisher']['signature'],
  );

  drupal_goto('dc-connect', array('query' => $query));
}
